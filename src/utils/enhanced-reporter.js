const report = require('multiple-cucumber-html-reporter');
const fs = require('fs');
const path = require('path');

/**
 * Enhanced Cucumber HTML Reporter
 * Generates beautiful HTML reports with screenshots and metadata
 */
class EnhancedReporter {
  constructor() {
    this.reportsDir = 'reports';
    this.screenshotsDir = 'screenshots';
    this.cucumberJsonPath = path.join(this.reportsDir, 'cucumber-report.json');
  }

  /**
   * Generate enhanced HTML report
   */
  async generateReport() {
    try {
      console.log('üé® Generating enhanced HTML report...');
      
      // Ensure reports directory exists
      if (!fs.existsSync(this.reportsDir)) {
        fs.mkdirSync(this.reportsDir, { recursive: true });
      }

      // Check if cucumber JSON report exists
      if (!fs.existsSync(this.cucumberJsonPath)) {
        console.error('‚ùå Cucumber JSON report not found. Please run tests first.');
        return;
      }

      // Read and process the JSON report
      const reportData = JSON.parse(fs.readFileSync(this.cucumberJsonPath, 'utf8'));
      console.log('Report data type:', typeof reportData);
      console.log('Is array:', Array.isArray(reportData));
      console.log('Report data:', JSON.stringify(reportData).substring(0, 200) + '...');
      
      // Generate the report
      report.generate({
        jsonDir: this.reportsDir,
        reportPath: this.reportsDir,
        reportName: 'Playwright Cucumber Test Report',
        pageTitle: 'Test Automation Results',
        displayDuration: true,
        displayReportTime: true,
        durationInMS: true,
        customMetadata: true,
        metadata: {
          browser: {
            name: process.env.BROWSER || 'chromium',
            version: 'Latest'
          },
          device: process.env.DEVICE || 'Desktop',
          platform: {
            name: process.platform,
            version: process.version
          },
          environment: process.env.TEST_ENV || 'staging',
          timestamp: new Date().toISOString(),
          buildNumber: process.env.BUILD_NUMBER || 'local',
          testType: 'E2E Automation',
          framework: 'Playwright + Cucumber + TypeScript'
        },
        customData: {
          title: 'Test Information',
          data: [
            { label: 'Project', value: 'Playwright TypeScript Cucumber Framework' },
            { label: 'Release', value: process.env.RELEASE_VERSION || '1.0.0' },
            { label: 'Test Environment', value: process.env.BASE_URL || 'https://the-internet.herokuapp.com' },
            { label: 'Execution Time', value: new Date().toLocaleString() },
            { label: 'Total Scenarios', value: this.getTotalScenarios(reportData) },
            { label: 'Browser', value: `${process.env.BROWSER || 'chromium'} (${process.env.HEADLESS !== 'false' ? 'Headless' : 'Headed'})` }
          ]
        },
        pageFooter: '<div style="text-align: center; margin-top: 20px;"><p>Generated by Playwright TypeScript Cucumber Framework</p></div>',
        reportSuiteAsScenarios: false,
        scenarioTimestamp: true,
        launchReport: true,
        collapseTests: true
      });

      console.log('‚úÖ Enhanced HTML report generated successfully!');
      console.log(`üìä Report location: ${path.resolve(this.reportsDir)}/index.html`);
      
      // Generate summary statistics
      this.generateSummaryReport(reportData);
      
    } catch (error) {
      console.error('‚ùå Error generating report:', error.message);
      throw error;
    }
  }

  /**
   * Generate summary statistics
   */
  generateSummaryReport(reportData) {
    const summary = this.calculateSummary(reportData);
    const summaryPath = path.join(this.reportsDir, 'test-summary.json');
    
    fs.writeFileSync(summaryPath, JSON.stringify(summary, null, 2));
    
    console.log('\nüìà Test Summary:');
    console.log(`   Total Features: ${summary.features.total}`);
    console.log(`   Total Scenarios: ${summary.scenarios.total}`);
    console.log(`   Passed: ${summary.scenarios.passed} ‚úÖ`);
    console.log(`   Failed: ${summary.scenarios.failed} ‚ùå`);
    console.log(`   Skipped: ${summary.scenarios.skipped} ‚è≠Ô∏è`);
    console.log(`   Success Rate: ${summary.scenarios.successRate}%`);
    console.log(`   Total Duration: ${summary.duration.total}ms`);
    console.log(`   Average Duration: ${summary.duration.average}ms per scenario`);
  }

  /**
   * Calculate test statistics
   */
  calculateSummary(reportData) {
    let totalFeatures = reportData.length;
    let totalScenarios = 0;
    let passedScenarios = 0;
    let failedScenarios = 0;
    let skippedScenarios = 0;
    let totalDuration = 0;

    reportData.forEach(feature => {
      if (feature.elements) {
        feature.elements.forEach(scenario => {
          totalScenarios++;
          
          const scenarioStatus = this.getScenarioStatus(scenario);
          switch (scenarioStatus) {
            case 'passed':
              passedScenarios++;
              break;
            case 'failed':
              failedScenarios++;
              break;
            case 'skipped':
              skippedScenarios++;
              break;
          }
          
          // Calculate duration
          if (scenario.steps) {
            scenario.steps.forEach(step => {
              if (step.result && step.result.duration) {
                totalDuration += step.result.duration;
              }
            });
          }
        });
      }
    });

    const successRate = totalScenarios > 0 ? Math.round((passedScenarios / totalScenarios) * 100) : 0;
    const averageDuration = totalScenarios > 0 ? Math.round(totalDuration / totalScenarios) : 0;

    return {
      timestamp: new Date().toISOString(),
      features: {
        total: totalFeatures
      },
      scenarios: {
        total: totalScenarios,
        passed: passedScenarios,
        failed: failedScenarios,
        skipped: skippedScenarios,
        successRate: successRate
      },
      duration: {
        total: totalDuration,
        average: averageDuration
      },
      environment: {
        browser: process.env.BROWSER || 'chromium',
        baseUrl: process.env.BASE_URL || 'https://the-internet.herokuapp.com',
        testEnv: process.env.TEST_ENV || 'staging'
      }
    };
  }

  /**
   * Get scenario status
   */
  getScenarioStatus(scenario) {
    if (!scenario.steps || scenario.steps.length === 0) {
      return 'skipped';
    }

    const hasFailedStep = scenario.steps.some(step => 
      step.result && step.result.status === 'failed'
    );
    
    if (hasFailedStep) {
      return 'failed';
    }

    const allStepsPassedOrSkipped = scenario.steps.every(step => 
      step.result && (step.result.status === 'passed' || step.result.status === 'skipped')
    );

    return allStepsPassedOrSkipped ? 'passed' : 'skipped';
  }

  /**
   * Get total scenarios from report data
   */
  getTotalScenarios(reportData) {
    let total = 0;
    if (Array.isArray(reportData)) {
      reportData.forEach(feature => {
        if (feature.elements) {
          total += feature.elements.length;
        }
      });
    }
    return total;
  }

  /**
   * Clean old reports
   */
  cleanOldReports() {
    console.log('üßπ Cleaning old reports...');
    
    const filesToClean = [
      path.join(this.reportsDir, 'index.html'),
      path.join(this.reportsDir, 'cucumber-report.html'),
      path.join(this.reportsDir, 'test-summary.json')
    ];

    filesToClean.forEach(file => {
      if (fs.existsSync(file)) {
        fs.unlinkSync(file);
        console.log(`   Removed: ${file}`);
      }
    });
  }
}

// Export for use in other modules
module.exports = EnhancedReporter;

// If run directly, generate report
if (require.main === module) {
  const reporter = new EnhancedReporter();
  
  const args = process.argv.slice(2);
  const shouldClean = args.includes('--clean');
  
  (async () => {
    try {
      if (shouldClean) {
        reporter.cleanOldReports();
      }
      
      await reporter.generateReport();
      
      console.log('\nüéâ Report generation completed successfully!');
      process.exit(0);
    } catch (error) {
      console.error('\nüí• Report generation failed:', error.message);
      process.exit(1);
    }
  })();
}